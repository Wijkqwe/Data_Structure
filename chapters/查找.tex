
\chapter{查找}

\[\begin{cases}
    \text{概念}\begin{cases}
        \text{静态} \\ 
        \text{动态}
    \end{cases} \\ 
    \text{线性结构}\begin{cases}
        \text{顺序} \\ 
        \text{折半/二分} \\ 
        \text{分块}
    \end{cases} \\ 
    \text{树形结构}\begin{cases}
        \text{二叉排序树} \\ 
        \text{二叉平衡树} \\ 
        \text{红黑树} \\ 
        \text{B树，B+树}
    \end{cases} \\ 
    \text{散列结构} \\ 
    \text{效率指标}
\end{cases}\]


\section{概念}

\subsection{查找}


\subsection{查找表}


\subsection{关键字}


\subsection{平均查找长度}
\[ASL = \sum_{i = 1}^nP_iC_i\]
n是查找表的长度，\(P_i\)是查找第i个数据元素的概率，\(C_i\)是找到第i个数据元素所进行的比较次数。


\section{线性}

\subsection{顺序}

\subsubsection{一般线性表}
\[ASL_{\text{成功}} = \sum_{i = 1}^nP_i(n - i + 1)\]
\[ASL_{\text{成功}} = \dfrac{n + 1}{2}\]


\subsubsection{有序线性表}
\[ASL_{\text{成功}} = \dfrac{n + 1}{2}\]
\[ASL_{\text{不成功}} = \sum_{i = 1}^nq_i(l_i - 1) = \dfrac{n}{2} + \dfrac{n}{n + 1}\]
其中，\(q_i\)是到达第i个失败结点的概率；\(l_i\)是第i个失败结点所在层数；


\subsubsection{二者}
查找成功的
\begin{itemize}
    \item ASL相同
    \item 平均时间相同
\end{itemize}


\subsection{折半/二分}
\(mid = \lfloor(low + high) / 2\rfloor\)

\subsubsection{判定树}
折半查找过程可用平衡二叉树描述，称为判定树
\[ASL_{\text{成功}} = \dfrac{1}{n}\sum_{i = 1}^nl_i = \dfrac{1}{n}(1 * 1 + 2 * 2 + ... + h * 2^{h - 1}) = \dfrac{n + 1}{n}\log_2(n + 1) - 1\]
树的高度\(h = \lceil\log_2(n + 1)\rceil\)。
\begin{enumerate}
    \item 根据n构建判定树
    \item 根据树计算ASL
\end{enumerate}
如n为12时，\(ASL_{\text{成功}} = (1 + 2 * 2 + 3 * 4 + 4 * 5) / 12,\ ASL_{\text{失败}} = (3 * 3 + 4 * 10) / 13\)



\subsubsection{效率}
最坏情况下，时间复杂度\(O(\log_2n)\)


\subsubsection{比较次数}
查找一个元素大约需要\(O(\log_2n)\)次比较；

最多不超过判定树的高度\(h = \lceil\log_2(n + 1)\rceil\);


\subsubsection{适用于}
必须满足两个条件
\begin{itemize}
    \item 数组或顺序表
    \item 有序
\end{itemize}


\subsection{分块}
索引顺序查找。

数据分成若干块，每块内数据不必有序，但块间必须有序，每块内最大（或最小）的数据组成索引块。

通常情况下，不要求每个索引块内元素个数相等。



设索引查找和块内查找ASL分别为\(L_I, L_S\)，则
\[ASL = L_I + L_S = \dfrac{b + 1}{2} + \dfrac{s + 1}{2} = \dfrac{s^2 + 2s + n}{2s}\]
将长度为n的查找表均分为b块，每块s个记录。若\(s = \sqrt{n}\)（最理想块长），则平均查找长度取最小值\(\sqrt{n} + 1\).


\subsubsection{比较次数}
为提高效率，对有序顺序表建立索引顺序结构，在最好情况下找表中已有元素：即每个索引块大小为\(\sqrt{n}\)，对索引项与索引块内使用折半查找，比较次数最多为\(\lceil\log_2(\sqrt{n} + 1)\rceil + \lceil\log_2(\sqrt{n} + 1)\rceil\)


\section{树形}

\subsection{二叉排序树}\label{二叉排序树}

\subsubsection{定义}
二叉排序树（或二叉查找树）是一颗空树，或是一颗具有以下特征的二叉树
\begin{itemize}
    \item 若左子树非空，则左子树上所有结点的值均小于根结点的值
    \item 若右子树非空，则右子树上所有结点的值均大于根结点的值
    \item 左右子树分别是二叉排序树
\end{itemize}


\subsubsection{性质/结论}
\begin{enumerate}
    \item 对二叉排序树进行中序遍历得到递增的有序序列。
    \item 理想情况下，树高度（深度）为\(\lceil\log_2(n + 1)\rceil\)
    \item 固定结点构成不同形态的二叉排序树，中序序列唯一
    \item n个互不相同的结点可构成的二叉排序树的形态数为n的卡特兰数，即先序序列的个数
\end{enumerate}


\subsubsection{查找}
是从根结点开始，沿某个分支逐层向下比较的过程。


\subsubsection{插入}
\begin{enumerate}
    \item 若原树为空，则直接插入
    \item 否则，若关键字k小于根结点值，则插入左子树，若大于则插入右子树
\end{enumerate}

\subsubsection{删除}
\begin{enumerate}
    \item 若被删结点z是叶结点，则直接删除
    \item 若z只有一颗子树，则让z子树直接成为z父结点的子树，替代z的位置
    \item 若z有两棵子树，则让z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱）
\end{enumerate}

\subsubsection{效率}
取决于树的高度。
\[ASL_{\text{成功}} = \dfrac{1}{n}\sum_{i = 1}^nl_i = \dfrac{1}{n}(1 * 1 + 2 * 2 + ... + h * 2^{h - 1})\]
若是平衡二叉树，则ASL与\(O(\log_2n)\)成正比。

最坏情况下，输入序列有序，则形成只有右子树的单支树，\(ASL = \dfrac{n + 1}{2}\)


\subsubsection{与二分比较}
\begin{itemize}
    \item 二分查找判定树唯一，二叉排序树查找不唯一
    \item 维护表的有序性，二叉排序树无需移动结点只需修改指针，平均执行时间\(O(\log_2n)\)；二分查找平均执行时间\(O(n)\)
    \item 当有序表是静态查找表时，宜用顺序表作为存储结构，采用二分查找；当有序表动态查找表时，应用二叉排序树作为逻辑结构
\end{itemize}


\subsection{平衡二叉树}\label{平衡二叉树}

\subsubsection{定义}
或称为AVL树，是一颗空树或是满足以下条件的二叉树
\begin{itemize}
    \item 左右子树高度差的绝对值不超过1
    \item 左右子树是平衡二叉树
\end{itemize}

多数教材定义为高度平衡的二叉排序树，统考命题可能定义为仅满足高度平衡的二叉树，不一定是二叉排序树。


\paragraph{平衡因子}
左子树与右子树的高度差为该结点的平衡因子，则平衡因子的值\(\in \{-1, 0, 1\}\)


\subsubsection{插入}
\begin{enumerate}
    \item 按二叉排序树方式插入结点
    \item 检查其路径上结点是否因此次操作导致不平衡
    \item 若导致不平衡，做出相应调整\begin{itemize}
        \item LL平衡旋转：在结点A的左孩子（L）的左子树（L）上插入结点，A的左孩子B上移代替A，A右下移成为B的右孩子，B的原右子树成为A的左子树
        \item RR：在A的右孩子（R）的右子树（R）上插入结点，A的右孩子B上移代替A，A左下移成为B的左孩子，B的原左子树成为A的右子树
        \item LR：在A的左孩子（L）的右子树（R）上插入结点，先将A的左孩子B的右孩子C上移代替B，B成为C的左孩子，C再向上移代替A，A成为C的右孩子
        \item RL：在A的右孩子（R）的左子树（L）上插入结点，先将A的右孩子B的左孩子C上移代替B，B成为C的右孩子，C再向上移代替A，A成为C的左孩子
    \end{itemize}
\end{enumerate}

\paragraph{特点}
每次调整的对象是最小不平衡子树，即路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。


\subsubsection{删除}
\begin{enumerate}
    \item 按二叉排序树方式删除结点w
    \item 检查其路径上结点是否因此次操作导致不平衡；若导致不平衡，从结点w开始向上回溯，找到第一个不平衡的结点z（最小不平衡子树）；y为结点z的高度最高的孩子；x是结点y的高度最高的孩子。
    \item 对以z为根的子树进行平衡调整\begin{itemize}
        \item y是z的左孩子，x是y的左孩子（LL）
        \item y是z的左孩子，x是y的右孩子（LR）
        \item y是z的右孩子，x是y的右孩子（RR）
        \item y是z的右孩子，x是y的左孩子（RL）
    \end{itemize}
    \item 若调整后子树高度减1，则可能需对z的祖先结点进行调整，甚至根结点（树高减1）
\end{enumerate}


\subsubsection{查找}
查找过程与二叉排序树相同。

含n个结点的平衡二叉树的最大深度为\(O(\log_2n)\)，平均查找效率为\(O(\log_2n)\)

\subsubsection{性质/结论}
\begin{enumerate}
    \item 红黑树和AVL树都属于自平衡的二叉树
    \item 红黑树和AVL树的查找、插入、删除操作的时间复杂度都为\(O(\log_2n)\)
    \item 含相同结点数时，与AVL树相比，AVL树的查询效率往往更优
    \item 设\(n_h\)表示高度h的平衡二叉树中所含的最少结点数，则\(n_1 = 1, n_2 = 2, n_h = n_{h - 1} + n_{h - 2} + 1\)
\end{enumerate}


\subsection{红黑树}\label{红黑树}
\subsubsection{定义}
在AVL树的平衡标准上进一步放宽条件，引入红黑树。

红黑树是满足以下红黑性质的二叉排序树：
\begin{enumerate}
    \item 每个结点是红色或黑色
    \item 根结点是黑色
    \item 叶结点（虚构的外部结点，NULL结点）都是黑色
    \item 不存在两个相邻的红结点（即红结点的父结点和孩子结点都是黑色）
    \item 对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点数相同
\end{enumerate}
为便于对红黑树的实现与理解，引入n + 1个外部结点，确保树中每个结点的左右孩子非空。

\paragraph{黑高}
从某结点出发，到达一个叶结点的任意一个简单路径上的黑结点总数称为该结点的黑高（记为bh）。根节点的黑高称为红黑树的黑高。


\subsubsection{插入}
\begin{enumerate}
    \item 按二叉排序树方式插入结点z，若z为根结点，则将结点着为黑色；否则将结点着为红色。
    \item 若z的父结点zp是红色，根据z的叔结点y的颜色进行调整
    \item 若y是黑色\begin{enumerate}
        \item 若zp是zpp的左孩子，且z是右孩子：LR。对z作左旋一次，令z为zp，zp为z，化为情况2，并按情况2再操作
        \item 若zp是zpp的左孩子，且z是左孩子：LL。交换zp与zpp的颜色并对zp作右旋一次，zpp成为zp的右孩子
        \item 若zp是zpp的右孩子，则分别对应RL与RR
    \end{enumerate}
    \item 若y是红色，则将zp与y着为黑色，将zpp着为红色，将zpp作为新结点z重复上述操作
\end{enumerate}


\subsubsection{删除}
\begin{enumerate}
    \item 按二叉排序树方式删除结点，若结点有两个孩子，找到该结点的中序后继填补，转为删除该后继结点，而后继结点至多只有一个孩子
    \item 若待删结点只有一个孩子，根据性质5，该孩子必为红色，则将该孩子着为黑色并替代待删结点
    \item 若待删结点无孩子且为红色，则可直接删除
    \item 若待删结点无孩子且为黑色，设待删结点为w，z为用来替代w的结点（当w为终端结点时，z为黑色NULL结点），将z路径上黑结点数量加1，此时破坏了性质1，此时删除操作转化为将双黑结点恢复为普通结点\begin{enumerate}
        \item 若z的兄弟节点x为红色，则x必有黑色孩子结点与父结点。交换x与zp的颜色，对x作一次左旋转，使zp成为x的左孩子。此时，z的新兄弟节点为旋转前x的一个孩子，为黑色，将情况转化为2，3，4
        \item 若z的兄弟节点x为黑色，x的右孩子是红色（RR），交换x与zp的颜色，将x的右孩子着为黑色，对x作一次左旋，使zp成为x的左孩子，将z变为单重黑色
        \item 若x为黑色，x的左孩子是红色（RL），交换x与其左孩子的颜色，对其左孩子左一次右旋，使x成为其原左孩子的右孩子，此时，将情况转为2
        \item 若x为黑色，x的两个孩子为黑色，将z置为单重黑色，将x着为红色，对zp额外着一层黑色，将zp作为新z循环；若原zp是红色，则将原zp着黑色，结束循环。
    \end{enumerate}
\end{enumerate}


\subsubsection{性质/结论}
\begin{enumerate}
    \item 从根结点到叶结点的最长路径不大于最短路径的2倍
    \item 有n个内部结点的红黑树高度\(h <= 2\log_2(n + 1)\)
    \item 新插入的红黑树的结点初始为红色
    \item 红结点数最大为黑结点数的2倍
    \item 若所有结点是黑色，则一定是满二叉树
    \item 红黑树和AVL树都属于自平衡的二叉树
    \item 红黑树和AVL树的查找、插入、删除操作的时间复杂度都为\(O(\log_2n)\)
    \item 含相同结点数时，与AVL树相比，AVL树的查询效率往往更优
\end{enumerate}


\subsection{B树}\label{B树}

\subsubsection{定义}
m阶B树是所有结点的平衡因子均等于0的m路平衡查找树。

一颗m阶B树或为空树，或为满足以下特性的m叉树：
\begin{enumerate}
    \item 树中每个结点至多有m颗子树，即至多有m - 1个关键字
    \item 若根结点不是叶结点，则至少有两棵子树，即至少一个关键字
    \item 除根结点外所有非叶结点至少有\(\lceil m / 2\rceil\)棵子树，即至少有\(\lceil m / 2\rceil - 1\)个关键字
    \item 所有非叶结点的结构如下：\begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
            \hline
            \(n\) & \(P_0\) & \(K_1\) & \(P_1\) & \(K_2\) & \(P_2\) & ... & \(K_n\) & \(P_n\) \\ 
            \hline
        \end{tabular}
    \end{center}其中\(K_i\)为结点的关键字，且满足\(K_1 < K_2 < ... < K_n\)；\(P_i\)为指向子树根结点的指针，且指针\(P_{i - 1}\)所指子树中所有结点的关键字均小于\(K_i\)，\(P_i\)所指子树中所有结点关键字均大于\(K_i\)；\(n\,\ (\lceil m / 2\rceil - 1 <= n <= m - 1)\)为结点中关键字的个数
    \item 所有叶结点\footnote{多数教材中定义为失败结点，408真题中定义为最底层的终端结点}都出现在同一层次上，且不带信息（可视为外部结点）。含n个关键字的B树含n + 1个叶结点。
\end{enumerate}


\subsubsection{查找}
包含两个基本操作：在B树中找结点；在结点内找关键字。B树常存储在磁盘上，因此前一操作在磁盘上进行，后一操作在内存中进行，即在磁盘上找到目标结点后将结点信息读入内存。因此，在磁盘上进行查找的次数即目标结点在B树上的层次数，决定B数的查找效率。

在B树上找到某个结点后，先在有序表中查找，若找到的查找成功，否则按照对应的指针信息到所指的子树中查找。查找到叶结点时，说明树中没有对应关键字，查找失败。


\subsubsection{高度}
应明确B树的高度不包括最后一层不带信息的叶结点（某些教材包括）。

若n >= 1，则对任意一棵包含n个关键字，高度为h，阶数为m的B树：
\begin{enumerate}
    \item 若让每个结点中的关键字个数达到最多，则容纳同样多关键字的B树的高度达到最小。
    \item \(n <= (m - 1)(1 + m + ... + m^{h - 1}) = m^h - 1\)
    \item \(h >= \log_m(n + 1)\)
    \item 若每个结点中关键字个数最少，则容纳同样多关键字的B树的高度最大。
    \item 第一层至少有1个结点，第二层至少有2个结点，第三层至少有\(2\lceil m / 2\rceil\)个结点，第\(h + 1\)层至少有\(2(\lceil m / 2\rceil)^{h - 1}\)个结点，而第\(h + 1\)层是叶结点，对于关键字为n的B树，叶结点数为\(n + 1\)，因此\(n + 1 >= 2(\lceil m / 2\rceil)^{h - 1}\)，即\(h <= \log_{m / 2}((n + 1) / 2) + 1\)
\end{enumerate}


\subsubsection{插入}
插入关键字key
\begin{enumerate}
    \item 定位。利用B树查找，找到key的终端结点（即表示查找失败的叶结点），插入位置为底部的非叶结点（叶结点的父结点）
    \item 插入。每个非根结点关键字数\(\in [\lceil m / 2\rceil - 1, m - 1]\)，若插入后关键字数小于m，则可之间插入；若大于m - 1，则对结点进行分裂
    \item 分裂。取一个新结点，在插入key后的原结点，从中间位置（\(\lceil m / 2\rceil\)），将其中关键字分为两部分，左部分包含的关键字在原结点中，右部分放入新结点，中间位置（\(\lceil m / 2\rceil\)）的结点插入父节点中。若父结点数超过上限，则继续分裂，直至根结点为止。
\end{enumerate}


\subsubsection{删除}
\begin{itemize}
    \item 若被删关键字k不在终端结点中，则使用k的前驱（或后继）替代k
    \item 若在终端中\begin{enumerate}
        \item 若k所在结点删除前关键字数 >= \(\lceil m / 2\rceil\)，则之间删除
        \item 若k所在结点删除前关键字数 = \(\lceil m / 2\rceil - 1\)，且与该结点相邻的左右兄弟结点的关键字数 >= \(\lceil m / 2\rceil\)，则将兄弟结点中与k所在结点邻近的关键字移入父结点中，并将父结点中兄弟结点与k所在结点之间的关键字移入k所在结点中，将k删除
        \item 若k所在结点删除前关键字数 = \(\lceil m / 2\rceil - 1\)，且与该结点相邻的左右兄弟结点的关键字数都为\(\lceil m / 2\rceil - 1\)，则将k所在结点与兄弟结点及二者之间的父结点的关键字合并为一个新结点，将k删除
        \item 若父结点为根结点且关键字数减一后为0，则删除根结点，新结点成为根结点；若非根结点且关键字数 <= \(\lceil m / 2\rceil - 2\)，则与其兄弟结点进行调整或合并，并重复上述步骤
    \end{enumerate}
\end{itemize}


\subsubsection{性质/结论}
\begin{enumerate}
    \item 在高度为h的B树中插入一个新关键字，根结点高度为1，假设插入过程中读入的结点一直在内存中，且初始时未读入内存，则本次插入操作产生的新结点个数最多\(h + 1\)，产生的磁盘读写次数最多为\(3h + 1\)
    \item B树结点中关键字最少的情况，即n个关键字在m阶B树中的最大深度h，前h层关键字总数\(n_h = 1 + 2 * (\lceil m / 2\rceil^{h - 1} - 1)\)
    \item 含n个非叶结点的m阶B树中至少包含\((n - 1)(\lceil m / 2\rceil - 1) + 1\)个关键字
\end{enumerate}


\subsubsection{适用于}
\begin{itemize}
    \item 操作系统文件索引，但读写代价比B+树高
\end{itemize}


\subsection{B+树}\label{B+树}

\subsubsection{定义}
是B树的变种树，一棵m阶B+树满足以下条件：
\begin{enumerate}
    \item 每个分支结点最多m棵子树
    \item 非叶根结点至少两棵子树，其余分支结点至少\(\lceil m / 2\rceil\)棵子树
    \item 结点子树数与关键字数相等
    \item 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，且相邻叶结点按大小顺序相互链接起来（即支持顺序查找）
    \item 所有分支结点（可视为索引的索引）中仅包含它的各个子结点（下一级索引）中关键字的最大值及指向其子结点的指针
\end{enumerate}


\subsubsection{与B树区别}
m阶B+树与m阶B树
\begin{enumerate}
    \item B+树中，n个关键字的结点只含n棵子树，每个关键字对应一棵子树；B树中，n个关键字的结点含n + 1棵子树
    \item B+树中，每个结点（非叶内部结点）的关键字数n的范围为\(\lceil m / 2\rceil <= n <= m\)（非叶根结点：\(2 <= n <= m\)）；B树中，每个结点（非叶内部结点）的关键字数n的范围为\(\lceil m / 2\rceil - 1 <= n <= m - 1\)（非叶根结点：\(1 <= n <= m - 1\)）
    \item B+树中，叶结点包含全部关键字，非叶结点中出现的关键字也会出现在叶结点中；B树中，最底层终端结点包含的关键字和其他结点包含的关键字是不重复的
    \item B+树中，叶结点包含信息，非叶结点仅索引作用，非叶结点的每个索引项只含对应子树的最大关键字和该树指针，不含对应记录的存储地址。使得一个磁盘块存储更多关键字，使磁盘读/写次数更少，查找速度更快
    \item B+树中，用一个指针指向关键字最小的叶结点，将所有叶结点串成一个线性链表
\end{enumerate}


\subsubsection{适用于}
\begin{itemize}
    \item 操作系统文件索引
    \item 数据库索引
\end{itemize}


\section{散列}

\subsection{定义}

散列函数（哈希函数）：一个把查找表中关键字映射成该关键字对应的地址的函数，记为Hash(key) = Addr。

冲突：两个及以上不同的关键字映射到同一地址；

同义词：发生冲突的不同关键字；

散列表（哈希表）：根据关键字直接进行访问的数据结构；


\subsection{构造}
\begin{enumerate}
    \item 散列函数的定义域必须包含全部关键字，值域范围则依赖散列表的大小
    \item 散列函数计算出的地址应尽可能均匀地分布在整个地址空间，尽可能减少冲突
    \item 散列函数应尽量简单，在较短时间内计算出任意一个关键字对应的散列地址
\end{enumerate}

\subsubsection{直接定址法}
散列函数为\(H(key) = key\ ||\ H(key) = a * key + b\)
其中a，b为常数，

适用于关键字分布基本连续的情况，若不连续则空位较多，造成空间浪费


\subsubsection{除留余数法}
散列函数为\(H(key) = key\ \%\ p\)，设散列表长为m，p为不大于但最接近或等于m的质数


\subsubsection{数字分析法}
设关键字是r进制数，而r个数码在各位上出现的概率不一定相同，可能在某些位上分布均匀一些，每种数码出现机会均等；而在某些位上分布不均匀，只有某几种数码经常出现。此时应选取数码分布较均匀的若干位作为散列地址。

适用于已知的关键字集合，更换关键字后需构造新散列函数


\subsubsection{平方取中法}
取关键字的平方值得中间几位作为散列地址。得到的散列地址与关键字的每位都有关系，使得散列地址分布比较均匀。

适用于关键字每位取值都不均匀或均小于散列地址所需位数


\subsection{处理冲突}
\(H_i\)表示处理冲突中第i次探测到的散列地址，假设得到的另一散列地址仍发生冲突，则继续求下一地址，直到\(H_k\)不发生冲突为止，\(H_k\)为关键字在表中的地址。

\subsubsection{开放定址法}
空闲地址既向同义词开放又向非同义词表项开放。数学递推公式为\(H_i = (H(key) + d_i)\ \% m\)，m为散列表长，\(d_i\)为增量序列。取定某一增量序列后，对应处理方法是确定的，通常有以下四种：
\begin{enumerate}
    \item 线性探测法，也称线性探测再散列法。\(d_i = 1, 2, ..., m - 1\)。特点是：发生冲突时，顺序查看表中下一单元，直到找出一个空闲单元或查遍全表。
    \item 平方探测法，也称二次探测法。\(d_i = 1^2, -1^2, 2^2, -2^2, ..., k^2, -k^2\)其中\(k <= m / 2\)。散列表长度m必须是可以表示为\(4k + 3\)的素数。该方法可避免出现“堆积”问题，缺点是不能探测到散列表上所有单元，但至少可探测到一半单元。
    \item 双散列法。\(d_i = i * Hash_2(key)\)。使用两个散列函数，第一个散列函数发生冲突时，利用第二个散列函数计算地址增量。具体散列函数为\(H_i = (H(key) + i * Hash_2(key))\ \%\ m\)
    \item 伪随机序列法。
\end{enumerate}


\subsubsection{拉链法}
将所有同义词存储到一个线性链表中，该线性链表由其散列地址唯一标识，查找插入删除操作通常在同义词链中进行。

适用于经常进行插入和删除的情况。


\subsection{查找}
对给定关键字key，根据散列函数计算散列地址
\begin{enumerate}
    \item 初始化\(Addr = Hash(key)\)
    \item 检查查找表中地址为Addr的位置上是否有记录\begin{itemize}
        \item 若无记录，返回查找失败
        \item 若有记录，比较其与key的值，若相等则返回查找成功；否则执行步骤3
    \end{itemize}
    \item 用给定的处理冲突方法计算“下一散列地址”，将Addr置此地址，执行步骤2
\end{enumerate}


\subsection{效率}
平均查找长度ASL为各关键字比较次数之和。以平均查找长度作为查找效率的度量。

查找效率取决于三个因素：\begin{itemize}
    \item 散列函数，
    \item 处理冲突方法，避免产生聚集（堆积）现象
    \item 装填因子\(\alpha = \dfrac{\text{表中记录数}n}{\text{散列表长度}m}\)定义为一个表的装满程度。
\end{itemize}

ASL
\begin{itemize}
    \item ASL依赖于装填因子\(\alpha\)而不直接依赖于n或m。
    \item ASL受冲突解决策略影响
    \item 堆积现象因冲突而产生，影响ASL
\end{itemize}







